<!DOCTYPE html>
<html lang="th" data-theme="light">
<head>
    <meta charset="UTF-8">
    <title>‡∏™‡∏ï‡∏π‡∏î‡∏¥‡πÇ‡∏≠‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ö‡∏ó‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á V10.1 (Final)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Thai:wght@400;500;600&family=Itim&family=Mitr:wght@400;500&family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --font-main: 'IBM Plex Sans Thai', -apple-system, sans-serif; --bg: #f8f9fa; --surface: #ffffff; --text-primary: #212529; --text-secondary: #6c757d; --border: #dee2e6; --primary: #0d6efd; --danger: #dc3545; --success: #198754; --warning: #ffc107; --info: #0dcaf0; --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); --radius: 12px; }
        [data-theme="dark"] { --bg: #121212; --surface: #1e1e1e; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --border: #333333; --primary: #4dabf7; }
        * { box-sizing: border-box; }
        body { font-family: var(--font-main); background-color: var(--bg); color: var(--text-primary); margin: 0; padding: 2rem; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 960px; display: flex; flex-direction: column; gap: 1.5rem; }
        h2, h3 { text-align: center; margin: 0 0 1rem 0; font-weight: 600; }
        #main-toolbar { background: var(--surface); padding: 1rem; border-radius: var(--radius); box-shadow: var(--shadow); border: 1px solid var(--border); display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 0.75rem; }
        .btn { display: inline-flex; align-items: center; gap: 0.5rem; font-family: inherit; font-size: 0.95rem; padding: 10px 18px; cursor: pointer; border: 1px solid transparent; border-radius: 8px; color: white; font-weight: 500; transition: all 0.2s ease; }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }
        #toggleButton { background-color: var(--success); }
        #toggleButton.recording { background-color: var(--danger); }
        #correctTextButton, #copyButton, #undoButton, #redoButton, #clearButton { background-color: var(--text-secondary); }
        .gemini-btn { background: linear-gradient(45deg, #4285F4, #9B72CB); }
        #editor-wrapper { position: relative; }
        #output { width: 100%; height: 450px; font-size: 18px; border: 1px solid var(--border); border-radius: var(--radius); padding: 1.5rem; line-height: 1.8; box-sizing: border-box; background-color: var(--surface); color: var(--text-primary); box-shadow: var(--shadow); resize: vertical; transition: font-size 0.2s, font-family 0.2s; }
        #stats-bar { position: absolute; bottom: 10px; right: 15px; font-size: 0.8rem; color: var(--text-secondary); background-color: rgba(255, 255, 255, 0.8); padding: 2px 8px; border-radius: 4px; }
        [data-theme="dark"] #stats-bar { background-color: rgba(0, 0, 0, 0.5); }
        #shortcut-zone { background-color: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 1rem; text-align: center; }
        .char-btn-wrapper { display: inline-block; position: relative; margin: 4px; }
        .char-btn { background-color: var(--warning); color: #333; padding: 8px 14px; cursor: grab; font-weight: 500; }
        .delete-btn { display: flex; align-items: center; justify-content: center; position: absolute; top: -8px; right: -8px; background-color: var(--danger); color: white; border-radius: 50%; width: 20px; height: 20px; border: none; cursor: pointer; font-size: 14px; opacity: 0; transition: all 0.2s; }
        .char-btn-wrapper:hover .delete-btn { opacity: 1; transform: scale(1.1); }
        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1.5rem; margin-top: 1.5rem; }
        .card { background: var(--surface); padding: 1.5rem; border-radius: var(--radius); box-shadow: var(--shadow); border: 1px solid var(--border); }
        .input-group { display: flex; gap: 0.75rem; align-items: center; }
        .input-group input, .input-group select { width: 100%; flex-grow: 1; padding: 10px; border: 1px solid var(--border); border-radius: 6px; font-size: 0.9rem; background-color: var(--bg); color: var(--text-primary); }
        /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö textarea ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô input-group */
        .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            background-color: var(--bg);
            color: var(--text-primary);
            resize: vertical; /* ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏î‡πâ */
        }
        #add-char-btn, #add-correction-btn { background-color: var(--info); }
        #save-api-key-btn { background-color: var(--primary); }
        #correction-list { list-style-type: none; padding: 0; margin-top: 1rem; max-height: 120px; overflow-y: auto; }
        .correction-item { display: flex; align-items: center; padding: 8px; border-bottom: 1px solid var(--border); position: relative; }
        #theme-toggle { position: fixed; top: 1rem; right: 1rem; background-color: var(--surface); border: 1px solid var(--border); width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2rem; box-shadow: var(--shadow); color: var(--text-secondary); }

        /* Modal Styles */
        .loading-overlay, .modal-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; 
            z-index: 1000; backdrop-filter: blur(5px); transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .loading-overlay.show, .modal-overlay.show {
            opacity: 1; visibility: visible; display: flex;
        }

        #message-modal, #confirm-modal {
            background-color: var(--surface); color: var(--text-primary); padding: 2rem; border-radius: var(--radius); 
            width: 90%; max-width: 400px; text-align: center; display: flex; flex-direction: column; align-items: center;
        }
        #message-content, #confirm-content { margin-bottom: 1rem; white-space: pre-wrap; text-align: center; }
        #confirm-modal .button-group { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; width: 100%; }

        /* Button styles for confirm modal */
        #confirm-modal #confirm-yes-btn {
            flex: 1; min-width: 80px;
            background: linear-gradient(135deg, #6DD5ED, #2193B0); /* Blue gradient */
            color: white; border: none; box-shadow: 0 4px 10px rgba(33, 147, 176, 0.4);
        }
        #confirm-modal #confirm-yes-btn:hover { background: linear-gradient(135deg, #2193B0, #6DD5ED); }

        #confirm-modal #confirm-no-btn {
            flex: 1; min-width: 80px;
            background: linear-gradient(135deg, #DA2C3A, #8A0707); /* Red gradient */
            color: white; border: none; box-shadow: 0 4px 10px rgba(138, 7, 7, 0.4);
        }
        #confirm-modal #confirm-no-btn:hover { background: linear-gradient(135deg, #8A0707, #DA2C3A); }
        /* End Button styles */

        .spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4285F4; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #review-modal { background-color: var(--surface); color: var(--text-primary); padding: 2rem; border-radius: var(--radius); width: 90%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column; }
        #review-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; border: 1px solid var(--border); border-radius: 8px; }
        .review-item { display: flex; align-items: center; gap: 1rem; padding: 0.75rem; border-bottom: 1px solid var(--border); }
        .review-item.rejected { opacity: 0.5; text-decoration: line-through; }
        .review-text { flex-grow: 1; }
        .review-text .original { color: var(--danger); text-decoration: line-through; }
        .review-text .corrected { color: var(--success); font-weight: 500; }
        .review-actions .action-btn { background: none; border: 1px solid var(--border); border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 1rem; transition: all 0.2s; }
        .review-actions .action-btn.accept { color: var(--success); }
        .review-actions .action-btn.reject { color: var(--danger); }
        .review-actions .action-btn:hover { background-color: var(--bg); }
        #review-footer { margin-top: 1.5rem; text-align: right; }

        .font-size-btn {
            font-weight: bold; width: 40px; height: 40px; padding: 0; flex-shrink: 0;
            background-color: var(--surface); color: var(--text-primary); border: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center;
        }
        #font-size-display { font-size: 1rem; font-weight: 500; min-width: 30px; text-align: center; }

        /* AI History Log */
        #ai-history-log {
            margin-top: 1.5rem; max-height: 300px; overflow-y: auto; display: flex; flex-direction: column;
            gap: 1rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: var(--radius);
            background-color: var(--bg);
        }
        .ai-history-entry {
            padding: 1rem; border: 1px solid var(--border); border-radius: var(--radius);
            background-color: var(--surface); box-shadow: var(--shadow);
        }
        .ai-response-content { white-space: pre-wrap; margin-bottom: 0.75rem; font-size: 0.95rem; line-height: 1.6; }

        /* YouTube Player Section */
        #youtube-player-container {
            margin-top: 1rem; width: 100%; height: 250px; background-color: #000; border-radius: 8px;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
        }
        #youtube-player-container iframe { width: 100%; height: 100%; border-radius: 8px; }
        #youtube-player-controls {
            display: flex; justify-content: center; gap: 0.75rem; margin-top: 1rem; flex-wrap: wrap;
        }
        #youtube-player-controls .btn {
            background-color: var(--primary); color: white; padding: 8px 15px; font-size: 0.9rem;
        }
        #youtube-single-search-group { display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem; align-items: stretch; }

        /* API Key Status */
        .api-key-status { /* ‡πÉ‡∏ä‡πâ class ‡πÅ‡∏ó‡∏ô id ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á 2 key */
            text-align: center; margin-top: 0.5rem; font-size: 0.85rem; padding: 5px 10px;
            border-radius: 6px; font-weight: 500;
        }
        .api-key-status.set { background-color: var(--success); color: white; }
        .api-key-status.unset { background-color: var(--danger); color: white; }

        /* YouTube Queue List */
        #youtube-queue-list {
            max-height: 200px; overflow-y: auto; padding: 1rem; border: 1px solid var(--border);
            border-radius: var(--radius); background-color: var(--bg); margin-top: 1rem; line-height: 1.5;
        }
        .youtube-queue-item {
            padding: 8px 10px; border-bottom: 1px dashed var(--border); display: flex;
            align-items: center; gap: 0.5rem; cursor: pointer; transition: background-color 0.2s ease;
        }
        .youtube-queue-item:last-child { border-bottom: none; }
        .youtube-queue-item:hover { background-color: rgba(108, 117, 125, 0.1); }
        .youtube-queue-item.current-playing {
            font-weight: bold; color: var(--primary); background-color: #e6f2ff; border-radius: 4px;
        }
        [data-theme="dark"] .youtube-queue-item.current-playing { background-color: #1a2a40; }
        .youtube-queue-item span { flex-grow: 1; }
        .youtube-queue-item .index { font-size: 0.8em; color: var(--text-secondary); min-width: 20px; text-align: right; }

        /* Saved Playlists List */
        #saved-playlists-list {
            max-height: 250px; /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå */
            overflow-y: auto;
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background-color: var(--bg);
            margin-top: 1rem;
        }

        .saved-playlist-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 10px;
            border-bottom: 1px dashed var(--border);
            transition: background-color 0.2s ease;
        }

        .saved-playlist-item:last-child {
            border-bottom: none;
        }

        .saved-playlist-item:hover {
            background-color: rgba(108, 117, 125, 0.1);
        }

        .saved-playlist-item .title {
            flex-grow: 1;
            font-weight: 500;
        }

        .saved-playlist-item .actions {
            display: flex;
            gap: 0.5rem;
        }

        .saved-playlist-item .actions .btn {
            padding: 6px 10px;
            font-size: 0.8rem;
            min-width: unset; /* Override min-width from general .btn */
        }
    </style>
</head>
<body>
    
    <button id="theme-toggle">üåô</button>

    <div class="container">
        <h2>‡∏™‡∏ï‡∏π‡∏î‡∏¥‡πÇ‡∏≠‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ö‡∏ó‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</h2>
        <div id="main-toolbar">
            <button id="undoButton" class="btn" title="‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö">‚Ü©Ô∏è ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>
            <button id="redoButton" class="btn" title="‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤">‚Ü™Ô∏è ‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>
            <button id="toggleButton" class="btn">üéôÔ∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏π‡∏î</button>
            <button id="correctTextButton" class="btn" title="‡πÅ‡∏Å‡πâ‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î (‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°)">‚úçÔ∏è ‡πÅ‡∏Å‡πâ‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î</button>
            <button id="copyButton" class="btn" title="‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î">üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å</button>
            <button id="clearButton" class="btn" title="‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°">üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°</button>
        </div>
        <div id="editor-wrapper">
            <textarea id="output" placeholder="..."></textarea>
            <div id="stats-bar"><span>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥: <span id="word-count">0</span></span> | <span>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£: <span id="char-count">0</span></span></div>
        </div>
        <div id="shortcut-zone" class="card"><h3>‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏±‡∏î‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£</h3></div>

        <div class="settings-grid">
            <div id="character-manager" class="card">
                <h3>‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£</h3>
                <div class="input-group">
                    <input type="text" id="character-input" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£...">
                    <button id="add-char-btn" class="btn">‡πÄ‡∏û‡∏¥‡πà‡∏°</button>
                </div>
            </div>
            <div id="view-manager" class="card">
                <h3>‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•</h3>
                <div id="font-controls" class="input-group">
                    <select id="font-selector">
                                <option value="'Sarabun', -apple-system, sans-serif">Sarabun (Default)</option>
                                <option value="'IBM Plex Sans Thai', sans-serif">IBM Plex Sans Thai</option>
                                <option value="'Mitr', sans-serif">Mitr</option>
                                <option value="'Itim', cursive">Itim</option>
                    </select>
                    <button id="font-size-down" class="btn font-size-btn">-</button>
                    <span id="font-size-display">18</span>
                    <button id="font-size-up" class="btn font-size-btn">+</button>
                </div>
            </div>
            <div id="ai-tools" class="card">
                <h3>‚ú® ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢ AI</h3>
                <div class="input-group" style="justify-content: center; gap: 10px;">
                    <button id="proofreadButton" class="btn gemini-btn">‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡∏î‡πâ‡∏ß‡∏¢ AI</button>
                    <button id="rephraseButton" class="btn gemini-btn">‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°</button>
                    <button id="titleButton" class="btn gemini-btn">‡∏Ñ‡∏¥‡∏î‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô</button>
                </div>
                <div class="input-group" style="flex-direction: column; align-items: stretch; margin-top: 1rem;">
                    <textarea id="custom-ai-prompt-input" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡πÄ‡∏ä‡πà‡∏ô '‡∏™‡∏£‡∏∏‡∏õ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ô‡∏µ‡πâ', '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå', '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö')... ‡πÇ‡∏î‡∏¢ AI ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö" rows="4"></textarea>
                    <button id="send-custom-prompt-btn" class="btn gemini-btn" style="margin-top: 0.75rem;">‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á AI</button>
                </div>
                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI</h4>
                <div id="ai-history-log">
                    <p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI</p>
                </div>
                <button id="clear-ai-history-btn" class="btn" style="background-color: var(--danger); margin-top: 1rem;">üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ AI</button>
            </div>
            <div id="api-key-manager" class="card">
                <h3>‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Gemini API Key</h3>
                <div class="input-group">
                    <input type="password" id="api-key-input" placeholder="‡∏ß‡∏≤‡∏á API Key ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà">
                    <button id="save-api-key-btn" class="btn gemini-btn">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
                </div>
                <div id="api-key-status" class="api-key-status">
                    </div>

                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key</h4>
                <div class="input-group">
                    <input type="password" id="youtube-api-key-input" placeholder="‡∏ß‡∏≤‡∏á YouTube Data API Key ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà">
                    <button id="save-youtube-api-key-btn" class="btn gemini-btn">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
                </div>
                <div id="youtube-api-key-status" class="api-key-status">
                    </div>
                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå YouTube (‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)</h4>
                <div class="input-group" style="flex-direction: column; align-items: stretch;">
                    <input type="text" id="youtube-playlist-input" placeholder="‡∏ß‡∏≤‡∏á URL ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå YouTube ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà">
                    <button id="load-youtube-playlist-btn" class="btn gemini-btn" style="margin-top: 0.75rem;">‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå</button>
                </div>
                <div id="youtube-player-container">
                    </div>
                <div id="youtube-player-controls">
                    <button id="prev-song-btn" class="btn">‚èÆÔ∏è ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>
                    <button id="play-pause-btn" class="btn">‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô</button>
                    <button id="next-song-btn" class="btn">‚è≠Ô∏è ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ</button>
                    <button id="shuffle-playlist-btn" class="btn">üîÄ ‡∏™‡∏∏‡πà‡∏°</button>
                    <span id="shuffle-status" style="margin-left: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);"></span> </div>
                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß</h4>
                <div class="input-group" style="flex-direction: column; align-items: stretch;">
                    <input type="text" id="youtube-single-search-input" placeholder="‡∏ß‡∏≤‡∏á URL ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ YouTube">
                    <button id="play-single-song-btn" class="btn gemini-btn" style="margin-top: 0.75rem;">‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠</button>
                </div>
                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô</h4>
                <div id="youtube-queue-list" class="card">
                    <p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß</p>
                </div>

                <h4 style="text-align: center; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--text-secondary);">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</h4>
                <div class="input-group" style="flex-direction: column; align-items: stretch;">
                    <input type="text" id="save-playlist-url-input" placeholder="‡∏ß‡∏≤‡∏á URL ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå YouTube ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å">
                    <button id="add-saved-playlist-btn" class="btn gemini-btn" style="margin-top: 0.75rem;">‚ûï ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå</button>
                </div>

                <div id="saved-playlists-list" class="card" style="margin-top: 1rem;">
                    <p style="text-align: center; color: var(--text-secondary);">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</p>
                </div>
                <button id="clear-all-saved-playlists-btn" class="btn" style="background-color: var(--danger); margin-top: 1rem;">üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                </div>
        </div>
        <div id="dictionary-manager" class="card">
            <h3>‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</h3>
            <div class="input-group">
                <input type="text" id="wrong-word-input" placeholder="‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î">
                <input type="text" id="correct-word-input" placeholder="‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å">
                <button id="add-correction-btn" class="btn">‡πÄ‡∏û‡∏¥‡πà‡∏°</button>
            </div>
            <ul id="correction-list"></ul>
        </div>
    </div>


    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <p>AI ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î...</p>
    </div>

    <div id="review-modal-overlay" class="modal-overlay">
        <div id="review-modal">
            <h3>‚ú® AI ‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î</h3>
            <ul id="review-list"></ul>
            <div id="review-footer">
                <button id="apply-changes-btn" class="btn gemini-btn">‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ä‡πâ</button>
                <button id="cancel-review-btn" class="btn" style="background-color: var(--text-secondary);">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
            </div>
        </div>
    </div>

    <div id="message-modal-overlay" class="modal-overlay">
        <div id="message-modal">
            <p id="message-content"></p>
            <button id="message-ok-btn" class="btn gemini-btn" style="margin-top: 1rem;">‡∏ï‡∏Å‡∏•‡∏á</button>
        </div>
    </div>

    <div id="confirm-modal-overlay" class="modal-overlay">
        <div id="confirm-modal">
            <p id="confirm-content"></p>
            <div class="button-group">
                <button id="confirm-yes-btn" class="btn gemini-btn">‡πÉ‡∏ä‡πà</button>
                <button id="confirm-no-btn" class="btn" style="background-color: var(--text-secondary);">‡πÑ‡∏°‡πà</button>
            </div>
        </div>
    </div>

    <script>
        // --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å DOM Elements ---
        const themeToggle = document.getElementById('theme-toggle');
        const toggleButton = document.getElementById('toggleButton');
        const output = document.getElementById('output');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const clearButton = document.getElementById('clearButton');
        const copyButton = document.getElementById('copyButton');
        const correctTextButton = document.getElementById('correctTextButton');
        const wrongWordInput = document.getElementById('wrong-word-input');
        const correctWordInput = document.getElementById('correct-word-input');
        const addCorrectionBtn = document.getElementById('add-correction-btn');
        const correctionList = document.getElementById('correction-list');
        const charInput = document.getElementById('character-input');
        const addCharBtn = document.getElementById('add-char-btn');
        const shortcutZone = document.getElementById('shortcut-zone');
        const wordCountEl = document.getElementById('word-count');
        const charCountEl = document.getElementById('char-count');
        const fontSelector = document.getElementById('font-selector');
        const fontSizeDownBtn = document.getElementById('font-size-down');
        const fontSizeUpBtn = document.getElementById('font-size-up');
        const fontSizeDisplay = document.getElementById('font-size-display');
        const loadingOverlay = document.getElementById('loading-overlay');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const proofreadButton = document.getElementById('proofreadButton');
        const rephraseButton = document.getElementById('rephraseButton');
        const titleButton = document.getElementById('titleButton');
        const reviewModalOverlay = document.getElementById('review-modal-overlay');
        const reviewList = document.getElementById('review-list');
        const applyChangesBtn = document.getElementById('apply-changes-btn');
        const cancelReviewBtn = document.getElementById('cancel-review-btn');
        const customAiPromptInput = document.getElementById('custom-ai-prompt-input');
        const sendCustomPromptBtn = document.getElementById('send-custom-prompt-btn');
        const aiHistoryLog = document.getElementById('ai-history-log');    
        const clearAiHistoryBtn = document.getElementById('clear-ai-history-btn');    
        
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö YouTube Player
        const youtubePlaylistInput = document.getElementById('youtube-playlist-input');
        const loadYoutubePlaylistBtn = document.getElementById('load-youtube-playlist-btn');
        const youtubePlayerContainer = document.getElementById('youtube-player-container');
        const prevSongBtn = document.getElementById('prev-song-btn');    
        const playPauseBtn = document.getElementById('play-pause-btn');    
        const nextSongBtn = document.getElementById('next-song-btn');    
        const shufflePlaylistBtn = document.getElementById('shuffle-playlist-btn');    
        const shuffleStatusEl = document.getElementById('shuffle-status');    
        const youtubeSingleSearchInput = document.getElementById('youtube-single-search-input');    
        const playSingleSongBtn = document.getElementById('play-single-song-btn');    
        const youtubeQueueList = document.getElementById('youtube-queue-list');    
        
        const apiKeyStatus = document.getElementById('api-key-status'); // Gemini API Key status element

        // NEW YouTube Data API Key Elements
        const youtubeApiKeyInput = document.getElementById('youtube-api-key-input');
        const saveYoutubeApiKeyBtn = document.getElementById('save-youtube-api-key-btn');
        const youtubeApiKeyStatus = document.getElementById('youtube-api-key-status'); // YouTube Data API Key status element

        // NEW Saved Playlists Elements
        const savePlaylistUrlInput = document.getElementById('save-playlist-url-input');
        const addSavedPlaylistBtn = document.getElementById('add-saved-playlist-btn');
        const savedPlaylistsList = document.getElementById('saved-playlists-list');
        const clearAllSavedPlaylistsBtn = document.getElementById('clear-all-saved-playlists-btn');

        let player; // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö YouTube Player
        let youtubeDataApiKey = ''; // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö YouTube Data API Key
        let geminiApiKey = ''; // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Gemini API Key

        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Modal ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô/‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
        const messageModalOverlay = document.getElementById('message-modal-overlay');
        const messageContent = document.getElementById('message-content');
        const messageOkBtn = document.getElementById('message-ok-btn');
        const confirmModalOverlay = document.getElementById('confirm-modal-overlay');
        const confirmContent = document.getElementById('confirm-content');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');
        let confirmCallback = null;


        let characters = [];
        let corrections = {};
        let draggedItem = null;
        let currentFontSize = 18;

        // --- YouTube Player State Management ---
        let currentPlaylistVideos = []; // Original order of video IDs in the current playlist
        let shuffledPlaylistVideos = []; // Shuffled order of video IDs
        let isPlayingShuffled = false; // Is shuffle mode active?
        let currentPlayingIndex = 0; // Current index in the active playlist (currentPlaylistVideos or shuffledPlaylistVideos)
        let savedPlaylists = []; // Array to store user's saved playlists [{ id, title, videoIds }]

        // --- Undo/Redo History ---
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY_SIZE = 100; // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥

        function saveState() {
            // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ (‡πÄ‡∏ä‡πà‡∏ô ‡∏°‡∏µ‡∏Å‡∏≤‡∏£ Undo ‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô)
            // ‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏´‡∏°‡πà
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }

            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            history.push(output.value);

            // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
            if (history.length > MAX_HISTORY_SIZE) {
                history.shift(); // ‡∏•‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            } else {
                historyIndex++;
            }
            updateUndoRedoButtons();
        }

        function loadState(index) {
            if (index >= 0 && index < history.length) {
                // ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ã‡πâ‡∏≥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î
                const tempOutputOnInput = output.oninput;
                output.oninput = null;

                output.value = history[index];
                output.dispatchEvent(new Event('input')); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤
                output.focus();
                historyIndex = index;
                updateUndoRedoButtons();
                
                // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ event listener ‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
                setTimeout(() => {
                    output.oninput = tempOutputOnInput;
                }, 0);
            }
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        // --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Modal ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô/‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏ö‡∏ö Custom ---
        function showMessage(message) {
            messageContent.textContent = message;
            messageModalOverlay.style.display = 'flex';
        }
        messageOkBtn.onclick = () => {
            messageModalOverlay.style.display = 'none';
        };

        function showConfirm(message, callback) {
            confirmContent.textContent = message;
            confirmCallback = callback;
            confirmModalOverlay.style.display = 'flex';
        }
        confirmYesBtn.onclick = () => {
            if (confirmCallback) {
                confirmCallback(true);
            }
            confirmModalOverlay.style.display = 'none';
        };
        confirmNoBtn.onclick = () => {
            if (confirmCallback) {
                confirmCallback(false);
            }
            confirmModalOverlay.style.display = 'none';
        };


        // --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: ‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô Speech Recognition ---
        if ('webkitSpeechRecognition' in window) {
            const recognition = new webkitSpeechRecognition();
            let isRecording = false;
            let beforeSelection = '';
            let afterSelection = '';
            recognition.continuous = true;
            recognition.lang = 'th-TH';
            recognition.interimResults = true;
            toggleButton.onclick = () => {    
                if (isRecording) {    
                    recognition.stop();    
                } else {    
                    beforeSelection = output.value.substring(0, output.selectionStart);    
                    afterSelection = output.value.substring(output.selectionEnd);    
                    if (output.selectionStart === output.selectionEnd && beforeSelection.length > 0 && !beforeSelection.endsWith(' ')) {    
                        beforeSelection += ' ';    
                    }    
                    recognition.start();    
                }    
            };
            recognition.onresult = event => {    
                let final_transcript = '';    
                let interim_transcript = '';    
                for (let i = 0; i < event.results.length; ++i) {    
                    if (event.results[i].isFinal) {    
                        final_transcript += event.results[i][0].transcript;    
                    } else {    
                        interim_transcript += event.results[i][0].transcript;    
                    }    
                }    
                output.value = beforeSelection + final_transcript + interim_transcript + afterSelection;    
                output.scrollTop = output.scrollHeight;    
            };
            recognition.onstart = () => {    
                isRecording = true;    
                toggleButton.textContent = '‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏û‡∏π‡∏î';    
                toggleButton.classList.add('recording');    
                output.focus();    
            };
            recognition.onend = () => {    
                isRecording = false;    
                toggleButton.textContent = 'üéôÔ∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏π‡∏î';    
                toggleButton.classList.remove('recording');    
                output.dispatchEvent(new Event('input'));    
                saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
            };
            recognition.onerror = event => {    
                console.error("Speech recognition error:", event.error);    
                isRecording = false;    
                toggleButton.textContent = 'üéôÔ∏è Error';    
                showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á: " + event.error);    
            };
        } else {
            document.querySelector('.container').innerHTML = '<h2>‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏û‡∏¥‡∏°‡∏û‡πå‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</h2>';
        }

        // --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Gemini API ---
        function showLoading(show) { loadingOverlay.style.display = show ? 'flex' : 'none'; }
        async function callGeminiAPI(prompt, jsonSchema = null) {
            if (!geminiApiKey) { showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Gemini API Key ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö"); return null; }
            showLoading(true);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            if (jsonSchema) { payload.generationConfig = { responseMimeType: "application/json", responseSchema: jsonSchema }; }
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`); }
                const data = await response.json();
                if (data.candidates && data.candidates[0].content.parts[0].text) { return data.candidates[0].content.parts[0].text; } else { return "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏à‡∏≤‡∏Å AI ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"; }
            } catch (error) {    
                console.error("Gemini API Error:", error);    
                showMessage("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Gemini API: " + error.message);    
                return null;    
            } finally {    
                showLoading(false);    
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI ‡∏•‡∏á‡πÉ‡∏ô‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
        function addAiResponseToHistory(promptUsed, aiResponse) {
            // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI" ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            const noHistoryMsg = aiHistoryLog.querySelector('p');
            if (noHistoryMsg && noHistoryMsg.textContent === '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI') {
                aiHistoryLog.innerHTML = '';
            }

            const responseEntry = document.createElement('div');
            responseEntry.className = 'ai-history-entry card'; // ‡πÉ‡∏ä‡πâ card style
            responseEntry.innerHTML = `
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                    <strong>‡∏Ñ‡∏∏‡∏ì‡∏™‡∏±‡πà‡∏á AI:</strong> "${promptUsed}"
                    <span style="float: right;">${new Date().toLocaleTimeString('th-TH', { hour: '2-digit', minute: '2-digit' })}</span>
                </div>
                <div class="ai-response-content">${aiResponse}</div>
                <button class="btn gemini-btn copy-ai-response-btn" style="padding: 8px 12px; font-size: 0.85rem;">üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏õ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏Å</button>
            `;
            aiHistoryLog.prepend(responseEntry); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏™‡∏∏‡∏î
            aiHistoryLog.scrollTop = 0; // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏õ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà

            // ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà
            responseEntry.querySelector('.copy-ai-response-btn').onclick = () => {
                output.value = aiResponse;
                output.dispatchEvent(new Event('input')); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤
                saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å
                showMessage("‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° AI ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
            };
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ AI
        clearAiHistoryBtn.onclick = () => {
            showConfirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?", (confirmed) => {
                if (confirmed) {
                    aiHistoryLog.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI</p>';
                    showMessage("‡∏•‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö AI ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
                }
            });
        };

        proofreadButton.onclick = async () => {
            const text = output.value;
            if (!text.trim()) return showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ AI ‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡∏ö");
            const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { original: { type: "STRING" }, corrected: { type: "STRING" }, reason: { type: "STRING" } }, required: ["original", "corrected", "reason"] } };
            const prompt = `‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏£‡∏£‡∏ì‡∏≤‡∏ò‡∏¥‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏∞‡∏Å‡∏î‡∏ú‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏û‡∏ö ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå JSON ‡∏ó‡∏µ‡πà‡∏°‡∏µ key: "original", "corrected", ‡πÅ‡∏•‡∏∞ "reason" ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏´‡πâ‡∏≤‡∏°‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏î‡∏ô‡∏≠‡∏Å‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏à‡∏≤‡∏Å‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå JSON\n\n---\n${text}\n---`;
            const resultJson = await callGeminiAPI(prompt, schema);
            if (resultJson) {    
                try {    
                    const suggestions = JSON.parse(resultJson);    
                    if (suggestions.length === 0) {    
                        showMessage("‚ú® ‡∏¢‡∏≠‡∏î‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°! AI ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡πÉ‡∏ô‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏£‡∏±‡∏ö");    
                        return;    
                    }    
                    displayReviewModal(suggestions);    
                } catch (e) {    
                    showMessage("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å AI ‡πÑ‡∏î‡πâ:\n" + resultJson);    
                }    
            }
        };
        function displayReviewModal(suggestions) {
            reviewList.innerHTML = '';
            suggestions.forEach((s, index) => {
                const item = document.createElement('li');
                item.className = 'review-item';
                item.dataset.index = index;
                item.dataset.original = s.original;
                item.dataset.corrected = s.corrected;
                item.dataset.status = 'accepted';
                item.innerHTML = `<div class="review-text"><span class="original">${s.original}</span> ‚Üí <span class="corrected">${s.corrected}</span><div style="font-size: 0.8em; color: var(--text-secondary);">${s.reason}</div></div><div class="review-actions"><button class="action-btn accept" title="‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö">‚úÖ</button><button class="action-btn reject" title="‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò">‚ùå</button></div>`;
                reviewList.appendChild(item);
            });
            reviewModalOverlay.style.display = 'flex';
        }
        reviewList.addEventListener('click', (e) => {    
            if (e.target.classList.contains('action-btn')) {    
                const item = e.target.closest('.review-item');    
                if (e.target.classList.contains('accept')) {    
                    item.dataset.status = 'accepted';    
                    item.classList.remove('rejected');    
                } else if (e.target.classList.contains('reject')) {    
                    item.dataset.status = 'rejected';    
                    item.classList.add('rejected');    
                }    
            }    
        });
        applyChangesBtn.onclick = () => {    
            let text = output.value;    
            const items = reviewList.querySelectorAll('.review-item');    
            items.forEach(item => {    
                if (item.dataset.status === 'accepted') {    
                    text = text.replaceAll(item.dataset.original, item.dataset.corrected);    
                }    
            });    
            output.value = text;    
            output.dispatchEvent(new Event('input'));    
            saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            reviewModalOverlay.style.display = 'none';    
            showMessage("‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");    
        };
        cancelReviewBtn.onclick = () => { reviewModalOverlay.style.display = 'none'; };

        rephraseButton.onclick = async () => {
            const selectedText = output.value.substring(output.selectionStart, output.selectionEnd);
            if (!selectedText.trim()) return showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≤‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ AI ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
            
            const prompt = `‡πÇ‡∏õ‡∏£‡∏î‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ô‡πà‡∏≤‡∏ï‡∏∑‡πà‡∏ô‡πÄ‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏î‡∏π‡∏î‡πÉ‡∏à‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏á‡πÉ‡∏à‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ:\n\n"${selectedText}"`;
            const result = await callGeminiAPI(prompt);
            if (result) {
                addAiResponseToHistory(`‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°: "${selectedText}"`, result);
            }
        };

        titleButton.onclick = async () => {
            const text = output.value;
            if (!text.trim()) return showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
            
            const prompt = `‡∏à‡∏≤‡∏Å‡∏ö‡∏ó‡∏™‡∏õ‡∏≠‡∏¢‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏∞‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ ‡πÇ‡∏õ‡∏£‡∏î‡∏ä‡πà‡∏ß‡∏¢‡∏Ñ‡∏¥‡∏î‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏î‡∏π‡∏î‡∏ú‡∏π‡πâ‡∏ä‡∏°‡∏°‡∏≤ 5 ‡∏ä‡∏∑‡πà‡∏≠ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô" ‡∏´‡∏£‡∏∑‡∏≠ "‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà" ‡∏ô‡∏≥‡∏´‡∏ô‡πâ‡∏≤ ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏¢‡πà‡∏≠‡∏¢:\n\n---\n${text}\n---`;
            const result = await callGeminiAPI(prompt);
            if (result) {
                const formattedResult = `--- üé¨ ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà AI ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ ---\n${result}\n---------------------------\n\n`;
                addAiResponseToHistory("‡∏Ñ‡∏¥‡∏î‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ô", formattedResult);
            }
        };

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á AI ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á
        sendCustomPromptBtn.onclick = async () => {
            const customPromptText = customAiPromptInput.value.trim();
            const mainContentText = output.value.trim();

            if (!customPromptText) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }
            if (!mainContentText) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÉ‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ AI ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•");
                return;
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á prompt ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏´‡∏•‡∏±‡∏Å
            const fullPrompt = `${customPromptText}\n\n--- ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á ---\n${mainContentText}\n---`;

            const result = await callGeminiAPI(fullPrompt);
            if (result) {
                addAiResponseToHistory(customPromptText, result);
                customAiPromptInput.value = ''; // ‡∏•‡πâ‡∏≤‡∏á‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏™‡πà‡∏á
            }
        };
        
        // --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 4: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ---
        const currentTheme = localStorage.getItem('theme');    
        if (currentTheme) {    
            document.documentElement.setAttribute('data-theme', currentTheme);    
            if (currentTheme === 'dark') themeToggle.textContent = '‚òÄÔ∏è';    
        }
        themeToggle.onclick = () => {    
            let theme = document.documentElement.getAttribute('data-theme');    
            if (theme === 'dark') {    
                document.documentElement.setAttribute('data-theme', 'light');    
                localStorage.setItem('theme', 'light');    
                themeToggle.textContent = 'üåô';    
            } else {    
                document.documentElement.setAttribute('data-theme', 'dark');    
                localStorage.setItem('theme', 'dark');    
                themeToggle.textContent = '‚òÄÔ∏è';    
            }    
        };
        copyButton.onclick = () => {    
            output.select();    
            document.execCommand('copy');    
            showMessage("‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");    
        };    
        
        // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Undo/Redo ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ history stack ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏≠‡∏á
        undoButton.onclick = () => {
            if (historyIndex > 0) {
                loadState(historyIndex - 1);
            }
        };
        redoButton.onclick = () => {
            if (historyIndex < history.length - 1) {
                loadState(historyIndex + 1);
            }
        };

        function renderCorrections() {    
            correctionList.innerHTML = '';    
            for (const wrong in corrections) {    
                const correct = corrections[wrong];    
                const item = document.createElement('li');    
                item.className = 'correction-item';    
                const textSpan = document.createElement('span');    
                textSpan.textContent = `'${wrong}' ‚Üí '${correct}'`;    
                item.appendChild(textSpan);    
                const deleteBtn = document.createElement('button');    
                deleteBtn.className = 'delete-btn';    
                deleteBtn.innerHTML = '&times;';    
                deleteBtn.title = "‡∏•‡∏ö‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡∏ô‡∏µ‡πâ";    
                deleteBtn.onclick = () => deleteCorrection(wrong);    
                item.appendChild(deleteBtn);    
                correctionList.appendChild(item);    
            }    
        }
        function addCorrection() {    
            const wrong = wrongWordInput.value.trim();    
            const correct = correctWordInput.value.trim();    
            if (wrong && correct) {    
                corrections[wrong] = correct;    
                wrongWordInput.value = '';    
                correctWordInput.value = '';    
                saveCorrections();    
                renderCorrections();    
            }    
        }
        function deleteCorrection(wrongWord) {    
            delete corrections[wrongWord];    
            saveCorrections();    
            renderCorrections();    
        }
        function saveCorrections() {    
            localStorage.setItem('userCorrectionsV4', JSON.stringify(corrections));    
        }
        function loadCorrections() {    
            const saved = localStorage.getItem('userCorrectionsV4');    
            const defaultCorrections = { "‡∏™‡∏ñ‡∏≤‡∏ô‡∏≤‡∏£": "‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå", "3‡∏≤‡∏£‡∏ñ": "‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ" };    
            corrections = saved ? JSON.parse(saved) : defaultCorrections;    
            renderCorrections();    
        }
        addCorrectionBtn.onclick = addCorrection;
        wrongWordInput.addEventListener("keyup", e => { if (e.key === "Enter") addCorrection(); });
        correctWordInput.addEventListener("keyup", e => { if (e.key === "Enter") addCorrection(); });

        function applyCorrections() {    
            let text = output.value;    
            const changesMade = [];    
            for (const wrongWord in corrections) {    
                const correctWord = corrections[wrongWord];    
                const regex = new RegExp(wrongWord, "g");    
                if (text.match(regex)) {    
                    const count = text.match(regex).length;    
                    text = text.replace(regex, correctWord);    
                    changesMade.push(`'${wrongWord}' ‚Üí '${correctWord}' (${count} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á)`);    
                }    
            }    
            if (changesMade.length > 0) {    
                output.value = text;    
                output.dispatchEvent(new Event('input'));    
                saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
                showMessage("‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:\n\n" + changesMade.join("\n"));    
            } else {    
                showMessage("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°‡∏Ñ‡∏£‡∏±‡∏ö");    
            }    
        }
        correctTextButton.onclick = applyCorrections;
        function renderButtons() {    
            shortcutZone.innerHTML = '<h3>‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏±‡∏î‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£</h3>'; // Ensure heading is always there
            if (characters.length === 0) {
                shortcutZone.innerHTML += '<p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</p>';
            }

            characters.forEach((char, index) => {    
                const wrapper = document.createElement('div');    
                wrapper.className = 'char-btn-wrapper';    
                wrapper.draggable = true;    
                wrapper.dataset.index = index;    
                const charBtn = document.createElement('button');    
                charBtn.className = 'btn char-btn';    
                charBtn.textContent = char;    
                wrapper.appendChild(charBtn);    
                const deleteBtn = document.createElement('button');    
                deleteBtn.className = 'delete-btn';    
                deleteBtn.innerHTML = '&times;';    
                deleteBtn.title = "‡∏•‡∏ö‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ô‡∏µ‡πâ";    
                deleteBtn.onclick = e => { e.stopPropagation(); deleteCharacter(index); };    
                wrapper.appendChild(deleteBtn);    
                wrapper.onclick = () => {    
                    const selectionStart = output.selectionStart;    
                    const selectionEnd = output.selectionEnd;    
                    const charText = `${char} `;    
                    if (selectionStart !== selectionEnd) {    
                        output.value = output.value.substring(0, selectionStart) + charText + output.value.substring(selectionEnd);    
                        output.selectionStart = output.selectionEnd = selectionStart + charText.length;    
                    } else {    
                        output.value += charText;    
                        output.scrollTop = output.scrollHeight;    
                    }    
                    output.focus();    
                    output.dispatchEvent(new Event('input'));    
                    saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏ó‡∏£‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
                };    
                shortcutZone.appendChild(wrapper);    
            });    
        }
        function addCharacter() {    
            const newChar = charInput.value.trim();    
            if (newChar && !characters.includes(newChar)) {    
                characters.push(newChar);    
                charInput.value = '';    
                saveCharacters();    
                renderButtons();    
            }    
        }
        function deleteCharacter(index) {    
            characters.splice(index, 1);    
            saveCharacters();    
            renderButtons();    
        }
        function saveCharacters() {    
            localStorage.setItem('animeCharactersV4', JSON.stringify(characters));    
        }
        function loadCharacters() {    
            const savedChars = localStorage.getItem('animeCharactersV4');    
            if (savedChars) {    
                characters = JSON.parse(savedChars);    
            }    
            renderButtons();    
        }
        shortcutZone.addEventListener("dragstart", e => {    
            draggedItem = e.target;    
            setTimeout(() => e.target.style.display = "none", 0);    
        });
        shortcutZone.addEventListener("dragend", e => {    
            e.target.style.display = "inline-block"; // Make it visible again immediately
            draggedItem = null;    
            // Reorder characters array based on the new DOM order
            const newOrderElements = Array.from(shortcutZone.querySelectorAll(".char-btn-wrapper"));
            characters = newOrderElements.map(wrapper => wrapper.querySelector(".char-btn").textContent);
            saveCharacters();    
            renderButtons(); // Re-render to ensure correct indexing and cleanup
        });
        shortcutZone.addEventListener("dragover", e => {    
            e.preventDefault();    
            if (draggedItem && e.target.closest('.char-btn-wrapper') !== draggedItem) {
                const afterElement = getDragAfterElement(shortcutZone, e.clientX);    
                if (afterElement == null) {    
                    shortcutZone.appendChild(draggedItem);    
                } else {    
                    shortcutZone.insertBefore(draggedItem, afterElement);    
                }    
            }
        });
        function getDragAfterElement(container, x) {    
            // Filter out the dragged item itself
            const draggables = [...container.querySelectorAll('.char-btn-wrapper')].filter(el => el !== draggedItem);
            
            return draggables.reduce((closest, child) => {    
                const box = child.getBoundingClientRect();    
                const offset = x - box.left - box.width / 2;    
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };    
                else return closest;    
            }, { offset: Number.NEGATIVE_INFINITY }).element;    
        }
        addCharBtn.onclick = addCharacter;
        charInput.addEventListener("keyup", e => { if (e.key === "Enter") addCharacter(); });
        function updateStats() {    
            const text = output.value;    
            charCountEl.textContent = text.length;    
            const words = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;    
            wordCountEl.textContent = words;    
        }
        function applySettings(font, size) {    
            output.style.fontFamily = font;    
            output.style.fontSize = `${size}px`;    
            fontSizeDisplay.textContent = size;    
        }
        function saveSettings(font, size) {    
            localStorage.setItem('editorFontFamily', font);    
            localStorage.setItem('editorFontSize', size);    
        }
        function loadSettings() {    
            const savedFont = localStorage.getItem('editorFontFamily') || "'Sarabun', -apple-system, sans-serif";    
            const savedSize = parseInt(localStorage.getItem('editorFontSize')) || 18;    
            currentFontSize = savedSize;    
            fontSelector.value = savedFont;    
            applySettings(savedFont, savedSize);    
        }
        fontSelector.onchange = () => {    
            const selectedFont = fontSelector.value;    
            applySettings(selectedFont, currentFontSize);    
            saveSettings(selectedFont, currentFontSize);    
        };
        fontSizeUpBtn.onclick = () => {    
            currentFontSize += 2;    
            applySettings(fontSelector.value, currentFontSize);    
            saveSettings(fontSelector.value, currentFontSize);    
        };
        fontSizeDownBtn.onclick = () => {    
            if (currentFontSize > 10) {    
                currentFontSize -= 2;    
                applySettings(fontSelector.value, currentFontSize);    
                saveSettings(fontSelector.value, currentFontSize);    
            }    
        };
        function saveContent() {    
            localStorage.setItem('scriptContentV4', output.value);    
        }
        function loadContent() {    
            const savedText = localStorage.getItem('scriptContentV4');    
            if (savedText) output.value = savedText;    
        }
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö input ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå
        output.addEventListener('input', () => {    
            updateStats();    
            saveContent();    
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
            // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ saveState ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ loadState() ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å
            // ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á output.value ‡∏à‡∏≤‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô
            if (output.value !== history[historyIndex]) {
                saveState();
            }
        });
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
        output.addEventListener('paste', () => {
            // setTimeout ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡πà‡∏≤ output.value ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            setTimeout(() => {
                saveState();
            }, 0);
        });

        clearButton.onclick = () => {
            showConfirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?", (confirmed) => {
                if (confirmed) {
                    output.value = '';
                    saveContent();
                    output.dispatchEvent(new Event('input'));
                    saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á
                }
            });
        };

        window.addEventListener('mousedown', e => { if (e.button === 4) { e.preventDefault(); toggleButton.click(); } });
        
        saveApiKeyBtn.onclick = () => {    
            const key = apiKeyInput.value.trim();    
            if (key) {    
                localStorage.setItem('geminiApiKey', key);    
                geminiApiKey = key;    
                updateApiKeyStatus(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API Key
                showMessage("API Key ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß!");    
                apiKeyInput.value = ''; // Clear input after saving
            } else {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà API Key ‡∏Ñ‡∏£‡∏±‡∏ö");
            }
        };
        function loadApiKey() {    
            const savedKey = localStorage.getItem('geminiApiKey');    
            if (savedKey) {    
                geminiApiKey = savedKey;    
                console.log("Gemini API Key loaded.");    
            }    
            updateApiKeyStatus(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API Key ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î
        }

        function updateApiKeyStatus() {
            // ‡∏î‡∏∂‡∏á Element ‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏à‡∏≤‡∏Å HTML ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            const geminiApiKeyStatusEl = document.getElementById('api-key-status');
            if (geminiApiKey) {
                geminiApiKeyStatusEl.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: Gemini API Key ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‚úÖ";
                geminiApiKeyStatusEl.className = "api-key-status set";    
            } else {
                geminiApiKeyStatusEl.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Gemini API Key ‚ùå";
                geminiApiKeyStatusEl.className = "api-key-status unset";    
            }
        }

        // --- YouTube Data API Key Management ---
        saveYoutubeApiKeyBtn.onclick = () => {
            const key = youtubeApiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('youtubeDataApiKey', key);
                youtubeDataApiKey = key;
                updateYoutubeDataApiKeyStatus();
                showMessage("YouTube Data API Key ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß!");
                youtubeApiKeyInput.value = ''; // Clear input after saving
            } else {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà YouTube Data API Key ‡∏Ñ‡∏£‡∏±‡∏ö");
            }
        };

        function loadYoutubeDataApiKey() {
            const savedKey = localStorage.getItem('youtubeDataApiKey');
            if (savedKey) {
                youtubeDataApiKey = savedKey;
            }
            updateYoutubeDataApiKeyStatus();
        }

        function updateYoutubeDataApiKeyStatus() {
            // ‡∏î‡∏∂‡∏á Element ‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏à‡∏≤‡∏Å HTML ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            const youtubeApiKeyStatusEl = document.getElementById('youtube-api-key-status');
            if (youtubeDataApiKey) {
                youtubeApiKeyStatusEl.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: YouTube Data API Key ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‚úÖ";
                youtubeApiKeyStatusEl.className = "api-key-status set";    
            } else {
                youtubeApiKeyStatusEl.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key ‚ùå";
                youtubeApiKeyStatusEl.className = "api-key-status unset";    
            }
        }

        // --- YouTube Player Functions (Updated for full control) ---

        function getPlaylistIdFromUrl(url) {
            try {
                const urlObj = new URL(url);
                const playlistId = urlObj.searchParams.get('list');
                if (playlistId) return playlistId;
                
                // Handle shortened URLs for playlists, if any
                // Example: youtube.com/playlist?list=PL...
                if (urlObj.hostname.includes('youtube.com') && urlObj.pathname.includes('playlist')) {
                    const pathParts = urlObj.pathname.split('/');
                    if (pathParts.length > 2 && pathParts[1] === 'playlist') {
                        return urlObj.searchParams.get('list'); // Re-check search param for list ID
                    }
                }

            } catch (e) {
                // Invalid URL
            }
            return null;
        }

        function getVideoIdFromUrl(url) {
            const videoIdMatch = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
            return videoIdMatch && videoIdMatch[1] ? videoIdMatch[1] : null;
        }

        async function getYoutubeVideoTitle(videoId, apiKey) {
            if (!videoId || !apiKey) return null;
            const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Error fetching YouTube video title:", errorData.error.message);
                    return null;
                }
                const data = await response.json();
                if (data.items && data.items.length > 0) {
                    return data.items[0].snippet.title;
                }
            } catch (error) {
                console.error("Error fetching YouTube video title (network/parse error):", error);
            }
            return null;
        }

        async function getYoutubePlaylistTitle(playlistId, apiKey) {
            if (!playlistId || !apiKey) return null;
            const apiUrl = `https://www.googleapis.com/youtube/v3/playlists?part=snippet&id=${playlistId}&key=${apiKey}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Error fetching YouTube playlist title:", errorData.error.message);
                    return null;
                }
                const data = await response.json();
                if (data.items && data.items.length > 0) {
                    return data.items[0].snippet.title;
                }
            } catch (error) {
                console.error("Error fetching YouTube playlist title (network/parse error):", error);
            }
            return null;
        }


        // NEW: Fetch all video IDs from a playlist (handling pagination)
        async function fetchPlaylistVideoIds(playlistId, apiKey) {
            if (!apiKey) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
                return [];
            }
            if (!playlistId) return [];

            showLoading(true); // Show loading spinner
            let allVideoIds = [];
            let nextPageToken = null;

            try {
                do {
                    const apiUrl = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${playlistId}&key=${apiKey}${nextPageToken ? `&pageToken=${nextPageToken}` : ''}`;
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json();
                        // Check for specific API key errors
                        if (errorData.error && errorData.error.message.includes('API key not valid')) {
                            showMessage("YouTube Data API Key ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏£‡∏±‡∏ö");
                        } else if (errorData.error && errorData.error.message.includes('quotaExceeded')) {
                            showMessage("YouTube Data API Key ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Å‡∏¥‡∏ô‡πÇ‡∏Ñ‡∏ß‡∏ï‡∏≤‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö");
                        } else {
                            showMessage(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå: ${errorData.error.message || response.statusText}`);
                        }
                        throw new Error(`YouTube API Error: ${errorData.error.message}`);
                    }
                    const data = await response.json();

                    if (data.items) {
                        data.items.forEach(item => {
                            if (item.snippet && item.snippet.resourceId && item.snippet.resourceId.videoId) {
                                allVideoIds.push(item.snippet.resourceId.videoId);
                            }
                        });
                    }
                    nextPageToken = data.nextPageToken;

                } while (nextPageToken);

                return allVideoIds;

            } catch (error) {
                console.error("Error fetching playlist video IDs:", error);
                // Error message already handled by showMessage above for API errors
                return [];
            } finally {
                showLoading(false); // Hide loading spinner
            }
        }


        function loadYouTubeIframeAPI() {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            } else {
                window.onYouTubeIframeAPIReady();
            }
        }

        window.onYouTubeIframeAPIReady = function() {
            // Player will be created only when a playlist is loaded or a single video is played
            youtubePlayerContainer.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á</p>';
        };

        // NEW: Function to create player with a specific video ID
        function createYouTubePlayer(videoId) {
            if (player) {
                player.destroy(); // Destroy old player if exists
            }
            
            youtubePlayerContainer.innerHTML = ''; // Clear existing content
            
            const playerDiv = document.createElement('div');
            playerDiv.id = 'youtube-iframe-player'; // Assign ID for YouTube Player
            youtubePlayerContainer.appendChild(playerDiv); // Append new player div

            player = new YT.Player('youtube-iframe-player', {
                height: '100%',
                width: '100%',
                videoId: videoId, // Play specific video
                playerVars: {
                    autoplay: 1,
                    controls: 1,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            event.target.playVideo();
            showMessage("‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå/‡πÄ‡∏û‡∏•‡∏á YouTube ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
            updatePlayPauseButton();
            updateShuffleStatus(); // Update initial status
            updateYoutubeQueueList(); // Ensure queue reflects current state
        }

        function onPlayerStateChange(event) {
            updatePlayPauseButton();
            if (event.data === YT.PlayerState.ENDED) {
                playVideoAtIndexAndHandleError(currentPlayingIndex + 1); // Auto play next in our managed queue
            }
        }

        function updatePlayPauseButton() {
            if (player && typeof player.getPlayerState === 'function') {
                const playerState = player.getPlayerState();
                if (playerState === YT.PlayerState.PLAYING || playerState === YT.PlayerState.BUFFERING) {
                    playPauseBtn.textContent = '‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î';
                } else {
                    playPauseBtn.textContent = '‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô';
                }
            } else {
                playPauseBtn.textContent = '‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô'; // Default state if player not ready
            }
        }

        // --- Core Error Handling and Auto-Skip Logic ---
        async function onPlayerError(event) {
            let errorMessage = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö YouTube Player: ";
            let continueToNext = false; // Flag to decide if we should try next video

            switch(event.data) {
                case 2: // Invalid ID, embedding disabled for this video, etc.
                    errorMessage += "ID ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏≠‡∏∑‡πà‡∏ô‡πÜ";
                    continueToNext = true; // Try next video
                    break;
                case 100: // Video not found
                    errorMessage += "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠";
                    continueToNext = true; // Try next video
                    break;
                case 101: // Embedding disabled for this video
                case 150: // Embedding disabled for this video (same as 101)
                    errorMessage += "‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå)";
                    continueToNext = true; // Try next video
                    break;
                default:
                    errorMessage += "‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏";
                    // For unknown errors, we might not want to auto-skip without more info
                    break;
            }
            
            showMessage(errorMessage);
            console.error("YouTube Player Error (Code:", event.data, "):", errorMessage, "Video ID:", player?.getVideoData()?.video_id);

            // If it's an error we want to skip, try next video
            if (continueToNext && currentPlaylistVideos.length > 0) {
                // Call the play next with error handling, ensuring we pass a skip count
                await playVideoAtIndexAndHandleError(currentPlayingIndex + 1, (player?.skipErrorCount || 0) + 1);
            } else {
                // If not skipping, or no more videos, reset player state
                youtubePlayerContainer.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">' + errorMessage + '<br>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏´‡∏°‡πà</p>';
                currentPlaylistVideos = [];
                shuffledPlaylistVideos = [];
                currentPlayingIndex = 0;
                isPlayingShuffled = false;
                updateYoutubeQueueList();
                updateShuffleStatus();
            }
        }

        // Updated function to play video at index, with built-in error skipping
        async function playVideoAtIndexAndHandleError(index, skipCount = 0) {
            const activePlaylist = isPlayingShuffled ? shuffledPlaylistVideos : currentPlaylistVideos;
            if (activePlaylist.length === 0) {
                showMessage("‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            // Calculate next index, handling loop
            let nextIndex = index;
            if (nextIndex >= activePlaylist.length) {
                nextIndex = 0; // Loop back to start
            } else if (nextIndex < 0) {
                nextIndex = activePlaylist.length - 1; // Loop to end
            }

            // Prevent infinite loop if all videos are broken
            if (skipCount >= activePlaylist.length) { // Try skipping all videos once.
                                                        // if it still fails, there's a serious problem.
                showMessage("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏î‡πÜ ‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏±‡∏ö ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î");
                player?.destroy(); // Destroy player if unable to play anything
                youtubePlayerContainer.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏î‡πÜ ‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏±‡∏ö<br>‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</p>';
                currentPlaylistVideos = []; shuffledPlaylistVideos = []; currentPlayingIndex = 0; isPlayingShuffled = false;
                updateYoutubeQueueList(); updateShuffleStatus();
                return;
            }

            currentPlayingIndex = nextIndex;
            const videoIdToPlay = activePlaylist[currentPlayingIndex];

            if (!videoIdToPlay) {
                showMessage("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà Index ‡∏ô‡∏µ‡πâ‡∏Ñ‡∏£‡∏±‡∏ö");
                // If videoIdToPlay is somehow null/undefined, try next one
                await playVideoAtIndexAndHandleError(currentPlayingIndex + 1, skipCount + 1);
                return;
            }

            // Store skipCount in player object to pass it through onPlayerError
            if (player) {
                player.skipErrorCount = skipCount;
            }

            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoIdToPlay);
                updateYoutubeQueueList(); // Update highlight immediately
            } else {
                // If player is not ready or not found, try to create it and load
                createYouTubePlayer(videoIdToPlay); // This will then trigger onPlayerReady/onPlayerError
                // If createYouTubePlayer also fails, onPlayerError will be called.
            }
        }


        // Updated event handlers for controls
        prevSongBtn.onclick = () => playVideoAtIndexAndHandleError(currentPlayingIndex - 1);
        nextSongBtn.onclick = () => playVideoAtIndexAndHandleError(currentPlayingIndex + 1);

        playPauseBtn.onclick = () => {
            if (player && typeof player.getPlayerState === 'function') {
                const playerState = player.getPlayerState();
                if (playerState === YT.PlayerState.PLAYING || playerState === YT.PlayerState.BUFFERING) {
                    player.pauseVideo();
                } else {
                    // If paused, just play. If not playing (e.g. initial state, or just created),
                    // try to play the current indexed song or first song if playlist exists.
                    if (currentPlaylistVideos.length > 0 && (player?.getVideoData()?.video_id !== currentPlaylistVideos[currentPlayingIndex] || !player?.getVideoData()?.video_id)) {
                        playVideoAtIndexAndHandleError(currentPlayingIndex); // Start playing current song if not already
                    } else if (player) {
                        player.playVideo();
                    }
                }
                updatePlayPauseButton();
            } else if (currentPlaylistVideos.length > 0) {
                // If player doesn't exist but we have a playlist, try creating player and playing first song
                playVideoAtIndexAndHandleError(currentPlayingIndex);
            } else {
                showMessage("YouTube Player ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏•‡∏á/‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå");
            }
        };

        shufflePlaylistBtn.onclick = () => {
            if (currentPlaylistVideos.length <= 1) {
                showMessage("‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            isPlayingShuffled = !isPlayingShuffled;

            if (isPlayingShuffled) {
                // If turning shuffle ON, create a new shuffled list
                shuffledPlaylistVideos = [...currentPlaylistVideos]; // Start with original order
                // Fisher-Yates (Knuth) shuffle algorithm
                for (let i = shuffledPlaylistVideos.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledPlaylistVideos[i], shuffledPlaylistVideos[j]] = [shuffledPlaylistVideos[j], shuffledPlaylistVideos[i]];
                }
                // Optionally, ensure the currently playing song remains first in the shuffled list
                const currentVideoId = player?.getVideoData()?.video_id;
                if (currentVideoId) {
                    const currentVideoIndexInShuffled = shuffledPlaylistVideos.indexOf(currentVideoId);
                    if (currentVideoIndexInShuffled > -1) {
                        shuffledPlaylistVideos.splice(currentVideoIndexInShuffled, 1);
                        shuffledPlaylistVideos.unshift(currentVideoId);
                        currentPlayingIndex = 0;
                    } else {
                        // If current song is not found in shuffled (e.g. was just skipped and not part of original)
                        currentPlayingIndex = 0; // Start from first shuffled song
                    }
                } else {
                    currentPlayingIndex = 0; // If no song playing, start from the first shuffled
                }
            } else {
                // If turning shuffle OFF, find the current song's index in the original playlist
                const currentVideoId = player?.getVideoData()?.video_id;
                if (currentVideoId) {
                    currentPlayingIndex = currentPlaylistVideos.indexOf(currentVideoId);
                    if (currentPlayingIndex === -1) {
                        currentPlayingIndex = 0;
                    }
                } else {
                    currentPlayingIndex = 0;
                }
            }
            
            updateShuffleStatus();
            updateYoutubeQueueList();

            // Load the new current song if it's different or if nothing was playing
            const activePlaylistAfterShuffle = isPlayingShuffled ? shuffledPlaylistVideos : currentPlaylistVideos;
            if (player && activePlaylistAfterShuffle[currentPlayingIndex] && player.getVideoData()?.video_id !== activePlaylistAfterShuffle[currentPlayingIndex]) {
                playVideoAtIndexAndHandleError(currentPlayingIndex);
            } else if (player && !player.getVideoData()?.video_id && activePlaylistAfterShuffle.length > 0) {
                playVideoAtIndexAndHandleError(currentPlayingIndex);
            }
            
            showMessage(`‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏∏‡πà‡∏°: ${isPlayingShuffled ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'}`);
        };


        playSingleSongBtn.onclick = async () => {
            const urlOrId = youtubeSingleSearchInput.value.trim();
            if (!urlOrId) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á URL ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ YouTube ‡∏´‡∏£‡∏∑‡∏≠ Video ID ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            const videoId = getVideoIdFromUrl(urlOrId) || urlOrId; 

            if (!youtubeDataApiKey) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Ñ‡∏£‡∏±‡∏ö");
                // Allow playing even without API key, just won't show title
            }
            
            // Clear current playlist and set to single video
            currentPlaylistVideos = [videoId];
            shuffledPlaylistVideos = [videoId];    
            isPlayingShuffled = false;
            currentPlayingIndex = 0;

            if (videoId) {
                createYouTubePlayer(videoId);
                updateShuffleStatus();
                updateYoutubeQueueList(); // This will show the single video in queue
                showMessage("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö!");
                youtubeSingleSearchInput.value = ''; // Clear input after playing
            } else {
                showMessage("‡πÑ‡∏°‡πà‡∏û‡∏ö Video ID ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å URL/‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏£‡∏±‡∏ö");
            }
        };


        async function updateYoutubeQueueList() {
            youtubeQueueList.innerHTML = '';
            const activePlaylist = isPlayingShuffled ? shuffledPlaylistVideos : currentPlaylistVideos;

            if (activePlaylist.length === 0) {
                youtubeQueueList.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß</p>';
                return;
            }

            if (!youtubeDataApiKey) {
                youtubeQueueList.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">‡πÑ‡∏°‡πà‡∏°‡∏µ YouTube Data API Key<br>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÑ‡∏î‡πâ</p>';
                activePlaylist.forEach((videoId, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'youtube-queue-item';
                    if (index === currentPlayingIndex) {
                        listItem.classList.add('current-playing');
                    }
                    listItem.dataset.index = index;
                    listItem.innerHTML = `<span class="index">${index + 1}.</span> <span>${videoId}</span>`; // Show ID if no API key
                    listItem.onclick = () => playVideoAtIndexAndHandleError(index);
                    youtubeQueueList.appendChild(listItem);
                });
                return;
            }

            // Fetch titles for all videos in the active playlist
            const fetchTitlesPromises = activePlaylist.map(videoId => getYoutubeVideoTitle(videoId, youtubeDataApiKey));
            const titles = await Promise.all(fetchTitlesPromises);

            titles.forEach((title, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'youtube-queue-item';
                if (index === currentPlayingIndex) {
                    listItem.classList.add('current-playing');
                }
                listItem.dataset.index = index;
                listItem.innerHTML = `<span class="index">${index + 1}.</span> <span>${title || 'Unknown Title'}</span>`;    
                listItem.onclick = () => playVideoAtIndexAndHandleError(index);
                youtubeQueueList.appendChild(listItem);
            });
            // Scroll to current playing song
            setTimeout(() => {
                const currentPlayingEl = youtubeQueueList.querySelector('.current-playing');
                if (currentPlayingEl) {
                    youtubeQueueList.scrollTop = currentPlayingEl.offsetTop - (youtubeQueueList.clientHeight / 2) + (currentPlayingEl.clientHeight / 2);
                }
            }, 100); // Small delay to ensure rendering
        }

        // Removed the old playVideoAtIndex, now directly call playVideoAtIndexAndHandleError for click events too
        // function playVideoAtIndex(index) { ... }

        function updateShuffleStatus() {
            shuffleStatusEl.textContent = `(‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏∏‡πà‡∏°: ${isPlayingShuffled ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'})`;
        }

        // --- NEW: Saved Playlists Management ---

        function saveSavedPlaylists() {
            localStorage.setItem('savedYoutubePlaylists', JSON.stringify(savedPlaylists));
        }

        function loadSavedPlaylists() {
            const saved = localStorage.getItem('savedYoutubePlaylists');
            savedPlaylists = saved ? JSON.parse(saved) : [];
            renderSavedPlaylists();
        }

        async function renderSavedPlaylists() {
            savedPlaylistsList.innerHTML = '';
            if (savedPlaylists.length === 0) {
                savedPlaylistsList.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</p>';
                return;
            }

            // For each saved playlist, create a list item
            for (const playlist of savedPlaylists) {    
                const listItem = document.createElement('div');
                listItem.className = 'saved-playlist-item';
                listItem.dataset.id = playlist.id;    

                const titleSpan = document.createElement('span');
                titleSpan.className = 'title';
                let displayTitle = playlist.title;

                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å API
                if (!displayTitle || displayTitle.includes('‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå (ID:') || playlist.videoIds === undefined || playlist.videoIds.length === 0) {    
                    if (youtubeDataApiKey) {
                        const newTitle = await getYoutubePlaylistTitle(playlist.id, youtubeDataApiKey);
                        if (newTitle) {
                            displayTitle = newTitle;
                            playlist.title = newTitle;    
                            // Try to re-fetch video IDs too if missing or corrupted
                            const fetchedVideoIds = await fetchPlaylistVideoIds(playlist.id, youtubeDataApiKey);
                            if (fetchedVideoIds.length > 0) {
                                playlist.videoIds = fetchedVideoIds;
                            }
                            saveSavedPlaylists();    
                        } else {
                            displayTitle = `‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå (ID: ${playlist.id}) (‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡∏∑‡πà‡∏≠)`;    
                        }
                    } else {
                        displayTitle = `‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå (ID: ${playlist.id}) (‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ API Key)`;    
                    }
                }
                titleSpan.textContent = displayTitle;
                listItem.appendChild(titleSpan);

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'actions';

                const playBtn = document.createElement('button');
                playBtn.className = 'btn gemini-btn';
                playBtn.textContent = '‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô';
                playBtn.onclick = async () => {
                    if (!youtubeDataApiKey) {
                        showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏Ñ‡∏£‡∏±‡∏ö");
                        return;
                    }
                    if (playlist.videoIds && playlist.videoIds.length > 0) {
                        currentPlaylistVideos = playlist.videoIds;
                        isPlayingShuffled = false;
                        shuffledPlaylistVideos = [...currentPlaylistVideos];    
                        currentPlayingIndex = 0;
                        await playVideoAtIndexAndHandleError(0);    
                        showMessage(`‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlist.title || playlist.id}" ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö`);
                    } else {
                        showMessage(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlist.title || playlist.id}" ‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà...`);
                        // Try to refetch video IDs if they were somehow missing
                        if (youtubeDataApiKey) {
                            const refetchedVideoIds = await fetchPlaylistVideoIds(playlist.id, youtubeDataApiKey);
                            if (refetchedVideoIds.length > 0) {
                                playlist.videoIds = refetchedVideoIds;
                                saveSavedPlaylists();
                                showMessage(`‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlist.title || playlist.id}" ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß ‡∏•‡∏≠‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á`);
                                // Now try playing after refetch
                                currentPlaylistVideos = playlist.videoIds;
                                isPlayingShuffled = false;
                                shuffledPlaylistVideos = [...currentPlaylistVideos];
                                currentPlayingIndex = 0;
                                await playVideoAtIndexAndHandleError(0);
                            } else {
                                showMessage(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlist.title || playlist.id}" ‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏±‡∏ö`);
                            }
                        }
                    }
                };
                actionsDiv.appendChild(playBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn';
                deleteBtn.style.backgroundColor = 'var(--danger)';
                deleteBtn.textContent = 'üóëÔ∏èÔ∏è ‡∏•‡∏ö';
                deleteBtn.onclick = () => {
                    showConfirm(`‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlist.title || playlist.id}" ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`, (confirmed) => {
                        if (confirmed) {
                            deleteSavedPlaylist(playlist.id);
                        }
                    });
                };
                actionsDiv.appendChild(deleteBtn);

                listItem.appendChild(actionsDiv);
                savedPlaylistsList.appendChild(listItem);
            }
        }

        async function addSavedPlaylist() {
            const url = savePlaylistUrlInput.value.trim();
            if (!url) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á URL ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå YouTube ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            const playlistId = getPlaylistIdFromUrl(url);
            if (!playlistId) {
                showMessage("URL ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà URL ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå YouTube ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            if (!youtubeDataApiKey) {
                showMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YouTube Data API Key ‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏Ñ‡∏£‡∏±‡∏ö");
                return;
            }

            // Check if playlist already exists
            const existingPlaylist = savedPlaylists.find(p => p.id === playlistId);
            if (existingPlaylist) {
                showMessage("‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
                savePlaylistUrlInput.value = '';
                return;
            }

            showLoading(true);
            try {
                const playlistTitle = await getYoutubePlaylistTitle(playlistId, youtubeDataApiKey);
                const videoIds = await fetchPlaylistVideoIds(playlistId, youtubeDataApiKey);

                if (videoIds.length === 0) {
                    showMessage("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏ô‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏±‡∏ö");
                    return; // Don't save if no videos
                }

                savedPlaylists.push({
                    id: playlistId,
                    title: playlistTitle || `‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå (ID: ${playlistId})`,
                    videoIds: videoIds // Store video IDs directly for faster access later
                });

                saveSavedPlaylists();
                renderSavedPlaylists(); // Re-render to show the new playlist
                showMessage(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå "${playlistTitle || playlistId}" ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!`);
                savePlaylistUrlInput.value = ''; // Clear input after saving

            } catch (error) {
                console.error("Error adding saved playlist:", error);
                // Error message already handled by sub-functions (fetchPlaylistVideoIds, getYoutubePlaylistTitle)
            } finally {
                showLoading(false);
            }
        }

        function deleteSavedPlaylist(playlistIdToDelete) {
            savedPlaylists = savedPlaylists.filter(p => p.id !== playlistIdToDelete);
            saveSavedPlaylists();
            renderSavedPlaylists();
            showMessage("‡∏•‡∏ö‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
        }

        clearAllSavedPlaylistsBtn.onclick = () => {
            showConfirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?", (confirmed) => {
                if (confirmed) {
                    savedPlaylists = [];
                    saveSavedPlaylists();
                    renderSavedPlaylists();
                    showMessage("‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö!");
                }
            });
        };

        addSavedPlaylistBtn.onclick = addSavedPlaylist;
        savePlaylistUrlInput.addEventListener("keyup", e => { if (e.key === "Enter") addSavedPlaylist(); });


        initializeApp();

        function initializeApp() {    
            loadContent();    
            loadCharacters();    
            loadSettings();    
            loadCorrections();    
            loadApiKey();    
            loadYoutubeDataApiKey();
            loadSavedPlaylists(); // Load saved playlists on app start
            updateStats();
            loadYouTubeIframeAPI(); // Load YouTube IFrame API when starting the app
            saveState(); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á output
        }
    </script>
</body>
</html>

